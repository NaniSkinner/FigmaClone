rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user is the owner
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to check if user is a super admin
    // Super admins have full control over all resources
    function isAdmin() {
      return isAuthenticated() && request.auth.uid == 'DiRAbITONAekBKXvXvblN8fUnuF3';
    }


    // Users collection - users can read all, but only write their own
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isOwner(userId);
    }

    // Presence collection - for real-time cursor tracking and selection
    // Users can read all presence data but only write their own
    match /presence/{userId} {
      allow read: if isAuthenticated();
      
      // Allow delete if owner OR if stale (older than 60 seconds) OR if admin
      allow delete: if isAdmin() || isOwner(userId) || 
        (isAuthenticated() && resource.data.lastSeen < request.time - duration.value(60, 's'));

      // Allow create with full validation (admins bypass validation)
      allow create: if isAdmin() || (isOwner(userId)
        && request.resource.data.keys().hasAll(['userId', 'lastSeen', 'cursor'])
        && request.resource.data.cursor.keys().hasAll(['x', 'y'])
        && request.resource.data.cursor.x is number
        && request.resource.data.cursor.y is number);

      // Allow update with partial data (for cursor position and selection updates)
      allow update: if isAdmin() || (isOwner(userId)
        && (!request.resource.data.keys().hasAny(['cursor']) ||
            (request.resource.data.cursor.keys().hasAll(['x', 'y'])
             && request.resource.data.cursor.x is number
             && request.resource.data.cursor.y is number))
        && (!request.resource.data.keys().hasAny(['selectedObjectIds']) ||
            request.resource.data.selectedObjectIds is list));
    }

    // Canvas collections - collaborative canvas objects
    // Locks are advisory only (client-side indicators), not enforced by security rules
    match /canvas/{canvasId}/objects/{objectId} {
      allow read: if isAuthenticated();

      // Create allowed for any authenticated user
      allow create: if isAuthenticated()
        && request.resource.data.keys().hasAll(['id', 'type'])
        && request.resource.data.id is string
        && request.resource.data.type is string
        // Optional AI metadata validation
        && (!request.resource.data.keys().hasAny(['createdByAI']) || request.resource.data.createdByAI is bool)
        && (!request.resource.data.keys().hasAny(['aiCommand']) || request.resource.data.aiCommand is string)
        && (!request.resource.data.keys().hasAny(['aiSessionId']) || request.resource.data.aiSessionId is string);

      // Update allowed for any authenticated user (soft locks only)
      allow update: if isAuthenticated();

      // Delete allowed for any authenticated user
      allow delete: if isAuthenticated();
    }

    // AI operations log - for tracking and analytics
    match /canvas/{canvasId}/ai-operations/{operationId} {
      allow read: if isAuthenticated();
      
      // Allow create for AI operation logs
      allow create: if isAuthenticated()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(['id', 'userId', 'command', 'timestamp', 'success']);
      
      // No updates or deletes (logs are immutable)
      allow update, delete: if false;
    }
  }
}
